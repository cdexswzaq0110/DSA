*** This is a Algorithm Application Problem Solving Exercises. ***

---Advance C/C++ Programs---

```
1. Divide and Conquer
----------------------------------------------------------------------------------------------------------------------------------------------------
- Idea: Break the problem into smaller subproblems, solve them recursively, and combine their solutions.
- Key Properties: Recursion, problem decomposition, merge step
- Common Use Cases: Sorting, searching, matrix multiplication
- Examples: Merge Sort, Quick Sort, Binary Search, Strassen’s Matrix Multiplication

2. Dynamic Programming (DP)
----------------------------------------------------------------------------------------------------------------------------------------------------
- Idea: Solve problems by combining solutions to overlapping subproblems. Store results to avoid redundant computation.
- Key Properties: Optimal substructure, overlapping subproblems, memoization or tabulation
- Common Use Cases: Optimization problems, sequences, paths
- Examples: Longest Common Subsequence (LCS), Matrix Chain Multiplication, Rod Cutting, Optimal Binary Search Tree, Fibonacci Sequence (DP version)

3. Greedy Algorithms
----------------------------------------------------------------------------------------------------------------------------------------------------
- Idea: Make the best local choice at each step, hoping this leads to a global optimum.
- Key Properties: Greedy-choice property, optimal substructure
- Common Use Cases: Resource allocation, scheduling, graph optimization
- Examples: Activity Selection, Huffman Coding, Kruskal’s Algorithm (Minimum Spanning Tree), Prim’s Algorithm (Minimum Spanning Tree), Dijkstra’s Algorithm (Shortest Paths)

4. Backtracking
----------------------------------------------------------------------------------------------------------------------------------------------------
- Idea: Explore all possible solutions recursively, abandoning paths that fail constraints (i.e., "backtrack").
- Key Properties: Search tree, recursion, constraint checking
- Common Use Cases: Combinatorial problems, constraint satisfaction
- Examples (general): N-Queens Problem, Subset Sum Problem, Solving Sudoku

5. Branch and Bound
----------------------------------------------------------------------------------------------------------------------------------------------------
- Idea: Systematically explore solution space like backtracking, but with bounds to prune unpromising paths.
- Key Properties: Pruning, cost estimation, optimization over search space
- Common Use Cases: NP-hard problems, exact optimization
- Examples: Traveling Salesman Problem (TSP), Integer Programming

6. Randomized Algorithms
----------------------------------------------------------------------------------------------------------------------------------------------------
- Idea: Incorporate randomness into the logic to improve performance or simplify implementation.
- Key Properties: Probabilistic decisions, expected performance
- Common Use Cases: Graph algorithms, selection, optimization
- Examples: Randomized Quick Sort, Randomized Min-Cut, Randomized Selection

7. Amortized Analysis
----------------------------------------------------------------------------------------------------------------------------------------------------
- Idea: Analyze the average time per operation over a sequence of operations, even if some operations are expensive.
- Key Properties: Aggregate, accounting, or potential methods
- Common Use Cases: Data structure operations
- Examples: Stack operations with dynamic arrays, Binary Counter, Fibonacci Heap operations
----------------------------------------------------------------------------------------------------------------------------------------------------
```

